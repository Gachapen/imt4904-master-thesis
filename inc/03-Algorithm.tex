% !TEX root = ../Masters.tex
\chapter{Distribution-based Grammar Evolution of L-system}

\section{Overview}
\label{sec:overview}
To generate \gls{L-system} plants that are aesthetically pleasing, varied and could be used to create offspring similar to its parents (\textbf{RQ0}), an algorithm called Distribution-based \gls{DGEL} was developed.

The \gls{DGEL} name consists of two parts that are essential to solve the three sub research questions: \textit{\gls{GE}} and \textit{Distribution-based}.
It uses \gls{GE} to evolve \gls{L-system} plants because it allows the algorithm to use well-researched techniques for modifying or combining genes into new \glspl{L-system} (\textbf{RQ1}).
As part of the \gls{GE} process, there is a fitness function that evaluates how aesthetically pleasing a plant is, thus pushing the evolution towards aesthetically pleasing plants (\textbf{RQ2}).
It is distribution-based, meaning that different probability distributions for the \gls{L-system} grammar can be used to generate varied plants (\textbf{RQ3}).

\begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{figures/dgel}
    \caption[DGEL components and flow]{\gls{DGEL} components and flow. Blue boxes represent processes and red boxes represent models. Grey boxes are logical collections of the components.}
    \label{fig:dgel}
\end{figure}

Figure~\ref{fig:dgel} illustrates the modules, processes and models of the \gls{DGEL} algorithm.
It consists of two modules: \textit{Evaluation} and \textit{Generation}.
Evaluation evaluates how good an \gls{L-system} plant is, and the Generation uses this information to generate good \gls{L-system} plants.
The end result is a plant 3D model that is interpreted from an \gls{L-system}.
The \gls{L-system} is generated by a chromosome using a grammar distribution for a grammar description.
These three models: the grammar description, grammar distribution and the chromosome, together define the \gls{L-system}.
All \glspl{L-system} generated using the same grammar description, grammar distribution and chromosome will result in the exact same \gls{L-system}, which also will be interpreted into the exact same plant 3D model.
\gls{GE} is used to generate a good chromosome based on the grammar description, grammar distribution and a fitness function.
The grammar distribution is generated by \gls{SA} based on the grammar description and a fitness function.
The fitness function models how aesthetically pleasing a plant is by assigning it a score in range $[0, 1]$, where 0 is the worst, and 1 is the best.

\section{Representing an L-system with Grammar}
\label{sec:grammar}
As described, the \glspl{L-system} in \gls{DGEL} are represented by a chromosome, a grammar description and a grammar distribution.
If we assume a uniform grammar distribution, only a chromosome and a grammar description is required.

The grammar description, represented in Augmented BNF (ABNF)~\cite{RFC5234}, describes the syntax of the \gls{L-system}.
For example, it may describe that an \gls{L-system} consists of a number of rules, each with a predecessor and successor, where a predecessor contains one character.
The chromosome describes the choices to be made in the grammar description, for example how many rules there are, or which character the predecessor contains.
These choices are what creates the variations in the \glspl{L-system}.
If there were no choices, there would only exist one single \gls{L-system}.

This method of representing the \glspl{L-system} was based on Beaumont and Stepney's work on applying \gls{GE} to plant \glspl{L-system}~\cite{2009Beaumont}, in addition to Ortega et al.'s work on applying it to fractal \glspl{L-system}~\cite{2003Ortega}, and Ryan et al.'s introduction of \gls{GE}~\cite{1998Ryan}.
Though instead of using traditional BNF, ABNF is used because of its support for repetitions with minimum and maximum, grouping and value ranges, and the fact that it has a simpler syntax~\cite{RFC5234}.

While Ortega et al.\ and Beaumont and Stepney make assumptions about the grammar to significantly simplify it and reduce the search space~\cite{2003Ortega, 2009Beaumont}, the \gls{DGEL} method uses a grammar that covers the largest search space reasonably possible.
To make the search space reasonable, there still has to be some limits.
The number of productions, string length, and number of characters for a variable were limited to a maximum of 20.
A higher number did not seem reasonable as no \glspl{L-system} in the literature reviewed used larger numbers, and the search times for higher numbers started to become unreasonably long.
% TODO: "unreasonable" and "Reasonable" are not really clear, or operationally defined. It is OKish, but, you could try to be more precise.
Additionally, to limit the complexity of \glspl{L-system}, complex features such as leaves, flowers, \gls{branch segment} width and more were not included.
Thus the grammar used can only produce the branches of a plant.
This is the most essential part of a plant, which can be expanded later by modifying only the grammar description.
Listing~\ref{lst:grammar} shows the actual grammar description used during the development and testing of the algorithm, while Listing~\ref{lst:grammar2} shows a grammar description that supports leaves and varying \gls{branch segment} width.

\begin{lstlisting}[caption={[ABNF grammar description used in DGEL]{ABNF grammar description used in \gls{DGEL}}}, label=lst:grammar, float]
lsystem = axiom productions
axiom = string
productions = 1*20production
production = predecessor successor
predecessor = variable
successor = string
string = 1*20(symbol / stack)
stack = "[" string "]"
symbol = variable / operation
variable = %x41-55
operation = "+" / "-" / "^" / "&" / ">" / "<"
\end{lstlisting}

\begin{lstlisting}[caption=ABNF grammar description supporting leaves and varying \gls{branch segment} width, label=lst:grammar2, float]
lsystem = axiom productions
axiom = string
productions = 1*20production
production = predecessor successor
predecessor = variable
successor = string
string = 1*20(symbol / stack / leaf)
symbol = variable / operation
variable = %x41-55
operation = "+" / "-" / "^" / "&" / ">" / "<" / "!"
stack = "[" string "]"
leaf = "['{+f-f-f+|+f-f}]"
\end{lstlisting}

To be able to use different grammar distributions, the chromosome representation is a different from that of Ryan et al.\ where each gene is an unsigned 8-bit integer and the choice to be made is the alternative index by the gene modulo the number of alternatives~\cite{1998Ryan}.
Each gene is still represented by an unsigned integer, but it is 32-bit instead of 8-bit, and the interpretation of the integer is different.

A gene in the \gls{DGEL} chromosome can be viewed as an index into the value range of the 32-bit integer.
This value range, from $0$ to $2^{32}$, can be viewed as a line with segments representing each alternative in a rule in the grammar.
In the case of a uniform distribution the segments would be equal in length, while for a different distribution the lengths will differ.
The value of each gene in the chromosome is randomly picked from a uniform distribution, thus making the actual distribution dependent on the grammar distribution.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/gene}
    \caption[Example grammar alternative selection from gene]{Example grammar alternative selection from gene. In the figure, the gene is a 3-bit integer, and therefore has 8 possible values.}
    \label{fig:gene}
\end{figure}

Figure~\ref{fig:gene} illustrates an example of this process.
A choice is to be made between $C$, $D$, $E$ and $F$ in the rule $A \rightarrow C / D / E / F$.
A chromosome of length 4 containing 4, 3, 0 and 7 is used, and the next gene to be used in the chromosome is the second position, i.e.\ the value 3.
Each gene is a 3-bit unsigned integer, therefore having 8 possible values in range $[0, 8)$.
Since there are four alternatives, and a uniform distribution is used, the 3-bit value range is split into four segments of 2 values.
The gene value 3 maps into the second segment, which maps to the second alternative in the rule, i.e.\ $D$.
This process would then continue with the next gene, 0, on the $D$ rule.

Obviously, a 3-bit integer can not always be split uniformly.
For example, if there are three alternatives, the closest approximation would be to have two segments cover three values and one cover two values, making one alternative have 12.5\% less chance of being selected.
An additional problem is that when the number of alternatives is higher than the available values, some alternatives are forced to have 0\% chance of being selected.
These issues can be mitigated by increasing the range of the integer, in this case to a 32-bit unsigned integer (used by \gls{DGEL}).
To prove this, consider the previous example only with a 32-bit integer instead.
Splitting it into three segments would yield two segments of size 1,431,655,765 and one of size 1,431,655,766 (1 in difference), and all of them would have a 33.33\% of being selected (rounded to two decimal places).
Even without rounding the value, there is only a \num{2.33e-8}\% difference between them.

\section{Interpreting L-systems Into Plant 3D Models}
\label{sec:interpreting}
As seen in Figure~\ref{fig:dgel}, after an \gls{L-system} has been generated, it needs to be interpreted into a 3D-model such that people may see the plant.
Turtle interpretation is used to do this~\cite{2012Prusinkiewicz}, because it is a popular method for 2D and 3D structure generation based on \glspl{L-system}.
A 3D version of the turtle interpretation is used, where the turtle can draw lines with \texttt{F}, and rotate around three axes using \texttt{-} and \texttt{+} for yaw, \texttt{\textasciicircum} and \texttt{\&} for pitch, and \texttt{<} and \texttt{>} for roll.
The bracket operators, \texttt{[} and \texttt{]}, are used to create \glspl{branch base}.
Table~\ref{tab:turtle-cmd} shows a complete overview of the characters and their operations, including extra operators used for more control and features like leaves (e.g.\ Listing~\ref{lst:grammar2}).

\begin{table}
    \centering
    \begin{tabular}{| c | l |}
    \hline
    \textbf{Character} & \textbf{Operation} \\ \hline
    F & Draw line forward \\ \hline
    + & Yaw left \\ \hline
    - & Yaw right \\ \hline
    \textasciicircum & Pitch up \\ \hline
    \& & Pitch down \\ \hline
    < & Roll left \\ \hline
    > & Roll right \\ \hline
    | & Yaw 180° \\ \hline
    [ & Push state \\ \hline
    ] & Pop state \\ \hline
    \{ & Begin surface \\ \hline
    \} & End surface \\ \hline
    ! & Decrease width \\ \hline
    ` & Next color \\ \hline
    f & Draw line forward \\
    \hline
    \end{tabular}
    \caption[Turtle interpretation of L-system characters]{Turtle interpretation of \gls{L-system} characters. \texttt{f} does the same as \texttt{F}, but is not allowed as a predecessor int the grammar such that it can not recurse.}
    \label{tab:turtle-cmd}
\end{table}

The actual 3D model created from this interpretation is kept as simple as possible while still trying to look somewhat natural.
The \glspl{branch segment} (created by the \texttt{F} character) are brown stretched cubes.
Leaves are green flat surfaces.
An example can bee seen in Figure~\ref{fig:example-model}.

\begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{figures/example-plant}
    \caption[Example 3D plant model generated by DGEL]{Example 3D plant model generated by \gls{DGEL}}
    \label{fig:example-model}
\end{figure}

As a discrete \gls{L-system} is used, the turtle interpretation requires some parameters that control the drawing.
While some evolutionary \gls{L-system} techniques evolve the turtle interpretation parameters as well as the \glspl{L-system}, to keep the process simple, \gls{DGEL} does not.
Additionally, if the discrete \gls{L-system} is swapped with a parametric \gls{L-system}, these parameters are no longer required.
The parameters used here were based on the 3D bush and 3D plant presented by Prusinkiewicz and Lindenmayer (Figures 1.25 and 1.26)~\cite{2012Prusinkiewicz}.
They can be seen in Table~\ref{tab:turtle-param}.

\begin{table}
    \centering
    \begin{tabular}{| l | l |}
    \hline
    \textbf{Parameter} & \textbf{Value} \\ \hline
    Width & 0.05 \\ \hline
    Angle & 22.5° \\ \hline
    Iterations & 5 \\ \hline
    Step & 0.2 \\
    \hline
    \end{tabular}
    \caption{Turtle interpretation parameters}
    \label{tab:turtle-param}
\end{table}

As described earlier, leaves and branches with varying widths are not included.
Without these, the plants may look ``dead'', and so can not be considered very aesthetically pleasing.
To work around this, widths of \glspl{branch segment} were heuristically set and leaves were heuristically placed.
These heuristics were based on observations of real plants and \gls{L-system} based 3D models such as the aforementioned models presented by Prusinkiewicz and Lindenmayer (Figures 1.25 and 1.26)~\cite{2012Prusinkiewicz}.

The \gls{branch segment} widths are determined by their distance from the branch top.
From a branch top, the segment width will increase by a fixed number towards the first \gls{branch base}.
In a \gls{branch base}, the width will be set to the largest of the child \glspl{branch segment}.
Then, the width will continue to increase towards the tree root.
Thus the plant will have natural-looking branches that are larger closer to the root.
Bigger plants will naturally have thicker branches than smaller plants.

Leaves are placed from the branch tops towards the root on each \gls{branch segment} in increasing sizes, until they become too big.
Thus, the leaves on the branch tops are the smallest, and they get bigger towards the root.
To prevent thick \glspl{branch segment}, e.g.\ the trunk of a tree, to have leaves directly placed on them, the leaves will no longer be placed when they reach a certain size.
The leaves are always pitched upwards, with a random noise applied to the pitch to look more natural.
They have a random rotation around the \gls{branch segment} they are placed on.

This interpretation of the \gls{L-system} can be swapped out with a different interpretation, while still using the \gls{DGEL} algorithm.
For example a more realistic interpretation with smoothed branches or branches bent by gravity could be used.
Thus the \gls{DGEL} algorithm is not dependent on this particular interpretation, but the results described later will be.

\section{Using a Grammar Distribution to Limit the Search Space}
In \gls{DGEL}, grammar distributions are used for three reasons: to guide the \gls{GE} to more efficiently find good plants, to guide \gls{GE} to search in a space with certain types of plants, and to prevent infinite recursion.

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{figures/distribution}
    \caption[Example grammar distribution]{Example grammar distribution applied to the second choice of rule $A$ at depth 0.}
    \label{fig:distribution}
\end{figure}

The distribution is a set of weights per choice per rule per depth, as illustrated in Figure~\ref{fig:distribution}.
The depth is the current branching depth of the \gls{L-system}, controlled by the bracket operators, and defined as the \texttt{stack} rule in the grammar in Listing~\ref{lst:grammar}.

The example figure shows a case where a choice is to be made between the alternatives C, D, E and F in rule $A \rightarrow *(C / D / E / F)$.
There are two different choices in the rule: selecting the number of repetitions (indicated by the asterisk character, \texttt{*}), and selecting the C/D/E/F alternative.
In the example, the depth is 0 (no branching), the rule is $A$ and the choice is the second.
This maps to the weight array: $[0.1, 0.4, 0.3, 0.2]$ which should be applied to the C/D/E/F choice.
Thus, $C$ has a 10\% chance of being selected, $D$ has 40\%, $E$ has 30\%, and $F$ has 20\%.
These weights are then used to define the segments in the gene, as described in Section~\ref{sec:grammar}.

If no weights are found in the distribution for a certain choice at a certain depth, the weights in the ``default'' depth will be used, if they exist.
If not, the weights will be uniform.
This can be used to prevent infinite recursion with the \texttt{stack} rule.
For example, the distribution for the grammar in Listing~\ref{lst:grammar} may specify the weights $[0.5, 0.5]$ for the second choice (\texttt{symbol / stack}) in the \texttt{string} rule at depth 0, 1 and 2, such that there is an equal chance to produce a string and a stack (\gls{branch base}).
To prevent any deeper \glspl{branch base}, the weights $[1.0, 0.0]$ may be specified in the default depth, causing it to not produce a stack at depth 3 or deeper.

By using a specialized distribution, rather than a uniform distribution, the generator may be targeted at specialized \glspl{L-system}, or just have a higher average fitness score for the generated plants.
For example, the distribution may focus more on producing the \texttt{F} character which is used for drawing the \glspl{branch segment}.
Or it may be focused on the \texttt{stack} rule that produces \glspl{branch base}.
This may in turn increase the rate of produced plants that have long or many branches.

In order to find specialized distributions that more efficiently generate good plants or generate different types of plants, the weights in the distribution need to be optimized.
As the distribution maps from depth, to rule, to choice, to alternative (weight), it is a four-dimensional parameter space.
\gls{DGEL} uses \gls{SA} to perform the optimization, but other multi-dimensional parameter optimizers could just as well be used.

Specifically, \gls{DGEL} implements the basic \gls{SA} approach~\cite{2000Ozdamar}, as described by Onbaşoğlu and Özdamar~\cite{2001Onbasoglu}.
The only difference is that the initial solution is not initialized randomly, but initialized from a pre-optimized solution, so that it has a better starting point.
In the \gls{DGEL} \gls{SA}, the \textit{solution} is the distribution itself, filled with weights for each of the alternatives in each of the choices in each of the rules in a limited set of depths.

A neighbor solution is generated in the same manner as Onbaşoğlu and Özdamar describes~\cite{2001Onbasoglu}: selecting one single random weight and either increasing or decreasing the weight randomly, bounded to the range $[0.0, 1.0]$ in the case of \gls{DGEL}.
A key difference is that since these are \textit{weights}, the remaining weights in the same set of weights have to be modified such that the sum of all of the weights equal 1.
If the sum of the remaining weights is greater than 0, they can be scaled by a normalization factor, calculated by $\frac{(1 - w)}{(1 - w_0)}$, where $w$ is the new value of the modified weight, and $w_0$ is the old value of the modified weight.
If the sum of the remaining weights is exactly 0, scaling the weights will not work, as they would remain 0.
The alternative solution is to divide the ``remaining weight'' over the remaining weights.
This is done by setting the remaining weights to $\frac{(1 - w)}{(n - 1)}$, where $w$ is the new value of the modified weight, and $n$ is the number of weights.

Accepting a neighbor solution also follows the same approach as Onbaşoğlu and Özdamar describes~\cite{2001Onbasoglu}.
To do this, an $f(x)$, where $x$ is a grammar distribution, has to be defined.
The performance of a grammar distribution can not directly be measured, but it can be estimated by measuring the average performance of the \glspl{L-system} it generates.
As the performance of the \glspl{L-system} generated may vary by a big degree, the average performance, $mean$, is only accepted after a specified amount of \glspl{L-system}, $n$, have been generated, and the standard error of the performance, $se$, is below a threshold value, $t$ (Algorithm~\ref{alg:eval-dist}).

\begin{algorithm}
\caption{Distribution evaluation}
\label{alg:eval-dist}
\begin{algorithmic}
\Function{evaluate\_dist}{$dist$, $n$, $t$}
    \State $samples\gets \Call{empty\_list}{}$
    \State $mean\gets UNDEFINED$
    \State $se\gets INFINITE$
    \While {$se\geq t$}
        \State $new\_samples\gets \Call{generate}{$n$, $dist$}$
        \State $samples\gets \Call{concat}{$samples$, $new\_samples$}$
        \State $mean\gets \Call{mean}{$samples$}$
        \State $se\gets \Call{standard\_error}{$samples$}$
    \EndWhile
    \State \Return $mean$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Using Grammar Evolution to Search the Space}
The main component of \gls{DGEL} is the \gls{GE} of the \glspl{L-system}, which is used to search the parameter space for the best \gls{L-system}.
The \gls{GE} process takes a grammar description and a grammar distribution as the input, and produces a single \gls{L-system} chromosome as the output.

It follows the process as described by Ryan et al.~\cite{1998Ryan}, but with some modifications to the representation as described in Section~\ref{sec:grammar}.
Ryan et al.\ do not describe the selection strategy they used, while Beaumont and Stepney use a simple selection strategy where a percentage of the best individuals are selected as parents~\cite{2009Beaumont}.
Since \gls{GE} is a specialization of \gls{GA}, \gls{GE} can use the same selection strategies as \gls{GA}.
Thus, tournament selection was selected for \gls{DGEL}, based on Blickle and Thiele's structured comparison of selection strategies~\cite{1995Blickle}, and Razali and Geraghty's comparison of selection strategies applied to the traveling salesman problem~\cite{2011Razali}.
Both tournament selection and ranking selection are recommended as good options, but tournament selection performs faster~\cite{1995Blickle}.
Therefore, because it is assumed that \gls{DGEL} may be used in real-time applications, tournament selection is preferred.

In order for the choice of tournament selection based on Blickle and Thiele's comparison to be valid, the \gls{GE} algorithm is implemented as \gls{GA} is described by Blickle and Thiele~\cite{1995Blickle}.
The only difference from the \gls{GA} algorithm is the addition of the duplication and prune operators that were specifically added to \gls{GE}~\cite{1998Ryan}.

\section{Using a Fitness Function to Evaluate Plants}
A crucial component of both the \gls{SA} and \gls{GE} process is the fitness function.
The fitness function is used by \gls{SA} to evaluate the grammar distributions, and by \gls{GE} to evaluate individual \glspl{L-system}.
Its function is to evaluate how ``good'' the \gls{L-system} plants are, or more specifically how ``aesthetically pleasing'' they are.
The literature on evolutionary \glspl{L-system} generally aim the fitness function at evaluating how realistic the plants are by using metrics such as its light gathering ability, positive phototropism and structural stability.

It is assumed that a baseline for aesthetically pleasing plants is that they look at least somewhat realistic, otherwise they would not look like plants at all.
Thus, the metrics used for the fitness function in \gls{DGEL} uses metrics from the literature, or metrics inspired from the literature, where the metrics usually are targeted towards realistic plants.
Additionally, the metrics were improved upon by generating a plants and looking for bad features in well-scored plants.
Following Ochoa~\cite{1998Ochoa}, each metric is weighted so that their importance may be tuned.
Table~\ref{tab:fitness} lists all of the metrics and their weight.

\begin{table}
    \centering
    \begin{tabularx}{\textwidth}{| l | X | l | l |}
    \hline
    \textbf{Metric} & \textbf{Description} & \textbf{Equation} & \textbf{Weight} \\
    \hline
    Nothing & Punish plants that have no branches (can not be seen) & \ref{eq:nothing} & 1 \\
    \hline
    Closeness & Punish plants with child \glspl{branch segment} very close to each other & \ref{eq:closeness} & 1 \\
    \hline
    Drop & Punish plants based on how much the plant grows downwards & \ref{eq:drop} & 1 \\
    \hline
    Balance & Reward plants that have their center of gravity closer to their root & \ref{eq:balance} & 1 \\
    \hline
    Branching & Reward plants with a balanced number of child branches & \ref{eq:complexity} & 1 \\
    \hline
    Foliage & Reward plants with more leaves & \ref{eq:foliage} & 1.5 \\
    \hline
    Length & Reward longer plants & \ref{eq:length} & 1 \\
    \hline
    Curvature & Reward plants that have somewhat curving branches & \ref{eq:curvature} & 0.4 \\
    \hline
    \end{tabularx}
    \caption{Fitness metrics}
    \label{tab:fitness}
\end{table}

The fitness metrics can be either rewarding, punishing, or both.
Rewarding metrics give a score of $[0,1]$, while punishing metrics score them $[-1,0]$ and metrics that are both score them $[-1,1]$.
Metrics that use the full range are considered punishing if the score is negative and rewarding if not.
Having these different ranges makes it possible to intuitively understand if the plant is good, bad or OK in terms of a metric.
The final fitness score is an summation of the rewarding and punishing scores, transformed to range $[0,1]$: $\frac{reward + punishment + 1}{2}$.
% TODO: comment on why I made it so...
% I may have made a mistake as I find no good argument for changing the range to 0--1 now... oh w/e

\textit{Nothing} is the simplest and most basic metric.
It punishes plants that have no \glspl{branch segment}.
This may happen if for example the \gls{L-system} contains no drawing commands (the character \texttt{F}).
Equation~\ref{eq:nothing} demonstrates this by giving it a score of -1 if it does not have any \glspl{branch segment}.
In this case no other metrics will make any difference.
The $branches$ function returns the number of \glspl{branch segment}.

Because of the recursive property of \glspl{L-system} and the flexible grammar used in \gls{DGEL}, the expanded string from running all the iterations may become very large.
For example, if the axiom contains the letter \texttt{F}, and the production \texttt{F} produces 20 \texttt{F}, with 5 iterations, the expanded string would have length $20^5$.
Additionally, the interpreted 3D model would consist of $20^5 + 1$ points, which is too much for the simple 3D renderer used.
Therefore the number of points in the interpreted 3D model is limited to 10,000 (skeleton limit).
If the \texttt{F} was instead a rotation operator, $20^5$ matrix multiplications would have to be performed, and the skeleton limit would not be breached.
Thus the number of instructions (i.e. characters in expanded string) is limited to a maximum of 50,000 (instruction limit).
Both limits were experimentally found to be balanced in time and space, while still allowing complex structures.
If they are breached the \gls{L-system} will become \textit{nothing} and thus be scored zero in the final fitness score.
\begin{equation}
\label{eq:nothing}
    nothing(x) =
    \begin{cases}
        0,& \text{if } branches(x) > 0  \\
        -1,& \text{otherwise}
    \end{cases}
\end{equation}

\textit{Closeness} is another punishing metric that punishes plants that have \glspl{branch base} with \glspl{child segment} too close to each other.
This metric helps avoid plants that have segments clipping into each other.
This clipping may look bad, and if they are completely inside each other the complexity of the 3D model increases, which decreases the rendering performance without improving visuals.
The dot product between the direction of two \glspl{child segment} is used for this metric.
The smaller the angle between the two direction vectors is, the larger the dot product is, becoming 1 when they are parallel.
If the largest dot product between segment directions in a \gls{branch base} is below a threshold, $t$, there is no punishment.
Otherwise, the plant is punished by a factor depending on how much above the threshold the dot product is.
This factor is interpolated between 0 and 1 linearly from the threshold to 1.
Equation~\ref{eq:closeness} shows how the closeness is calculated.
The $closest$ function finds the closest dot product between \glspl{child segment} in a \gls{branch base}.
The threshold was experimentally set to 0.9 to punish plants that have segments that look like they clip into each other.

\begin{equation}
\label{eq:closeness}
    closeness(x) =
    \begin{cases}
        0,& \text{if } closest(x) < t \\
        -\frac{c - t}{(1 - t)},& \text{otherwise}
    \end{cases} \\
\end{equation}

\textit{Drop} is a third punishing metric that punishes plants that grow downwards.
It finds the lowest point on the plant, and punishes the plant if it is below 0.
Equation~\ref{eq:drop} demonstrates this.
The $lowestpoint$ function returns the smallest value of the y-component of all points on the plant.
This value is then clamped in the range -1 and 1 and interpolated using a sine function to quickly increase the punishment.
Thus plants where the lowest point is 0 or above will not be punished, while on plants where it is -1 or below will be punished by -1.

\begin{equation}
\label{eq:drop}
drop(x) = sin(clamp(lowestpoint(x), -1, 0) * \frac{\pi}{2})
\end{equation}

\textit{Balance} is a measure of how well balanced the weight of the plant is.
It is inspired by the Bilateral Symmetry measure by Ochoa where 2D plants that reach equally far both left and right are rewarded the most~\cite{1998Ochoa}.
A different approach has to be taken in 3D where there are not only two horizontal directions, but rather an infinite number.
The approach taken is to estimate where the center of gravity of the plant is, calculate the horizontal distance, $centerdistance$, to it, and compare it to how far the plant reaches, $centerspread$, in the horizontal direction of the center of gravity.
This is done by Equation~\ref{eq:balance}.
In the worst case, if both $centerdistance$ and $centerspread$ are the same, the plant will be punished by -1.
In the best case, if the $centerdistance$ is 0, i.e.\ the gravitational center is in the center of the plant, the plant will be rewarded by 1.
Since $centerdistance$ generally will increase with increasing $centerspread$, the plant will be more punished the more it spreads out in one direction.
Though by having most of its \glspl{branch segment} close to the root, it may mitigate the punishment.
Thus the fraction $\frac{centerdistance}{centerspread}$ is used.

\begin{equation}
\label{eq:balance}
balance(x) = (0.5 - \frac{centerdistance(x)}{centerspread(x)}) * 2
\end{equation}

\textit{Branching} measures how complex the branching of the plant is.
It is inspired by the Structural Stability~\cite{1998Ochoa}, Plant Structural Stability~\cite{2009Corchado} and Proportion of Branch Bases~\cite{1998Ochoa} measures.
These measures assume that the plant becomes too unstable to survive if it has too many \glspl{child segment} growing from a \gls{branch base}.
Corchado et al.\ additionally assume that plants with too few branches will have worse light gathering ability.
Thus there will be a sweet spot in the branching proportion which is rewarded the most.
If the proportion is too low or too high, the plant will be punished.
This is shown in Equation~\ref{eq:complexity} where if the branching proportion is below 1.2 (1.2 \glspl{child segment} from a \gls{branch base} on average), or above 5, it will be punished in range $[-1, 0]$.
While between 1.2 and 5, it will be rewarded in range $[0, 1]$.
The sweet spot is 2, where it will be rewarded by 1.
$icos$ interpolates the value from the first parameter, $a$, to the second parameter, $b$, using a cosine function.
The third parameter, $t$, is in range $[0, 1]$ and controls where between $a$ and $b$ the interpolation is.
This creates a smooth curve between the limits.

\begin{equation}
\label{eq:complexity}
\begin{aligned}
    branching(x) =
    \begin{cases}
        -1, & b < 1 \\
        icos(-1, 0, \frac{b - 1.0}{0.2}), & b < 1.2 \\
        icos(0, 1, \frac{b - 1.2}{0.8}), & b < 2 \\
        1, & b < 3 \\
        icos(1, -1, \frac{b - 3}{5.8}), & b < 7 \\
        -1, & \text{otherwise}
    \end{cases}, \\
    \text{where } b = \frac{branches(x)}{branchings(x)}
\end{aligned}
\end{equation}

\textit{Foliage} measures how many leaves a plant has.
It is the main metric for measuring the light gathering ability of the plant, and is inspired by Ochoa~\cite{1998Ochoa}, Ebner~\cite{2003Ebner}, and Corchado et al.'s~\cite{2009Corchado} light gathering ability metrics.
The main point is that more leaves exposed to sunlight means that the plant has a better ability to survive.
For simplicity, the metric used in \gls{DGEL} is based on Corchado et al.'s metric which simply rewards plants with more leaves~\cite{2009Corchado}.
It also counts leaves that are shadowed by other leaves, even though in reality these would gather only minimal amounts of light.
This selection of method was due to time constraints, and a more complex method like Ebner's would be better.
The metric used starts with a reward of 0 for 0 leaves and is asymptotic towards 1 when the leaf count, found by $leaves$, increases towards $\infty$.
Equation~\ref{eq:foliage} demonstrates this.
The $s$ constant controls how fast it should increase towards 1.

\begin{equation}
\label{eq:foliage}
    foliage(x) = \frac{leaves(x) * s}{1 + leaves(x) * s}, \text{where } s = 0.1
\end{equation}

\textit{Length} rewards plants that are longer.
It is inspired by Ochoa and Corchado et al.'s Positive Phototropism metrics where the assumption is that plants grow towards the sunlight and therefore taller plants are better at surviving.
While Positive Phototropism only cares about the height of the plant, Length cares about how long the plant is, not considering if it grows upwards or not.
This change is made on the assumption that plants can gather more light both by growing upwards (cover more vertical area) and sideways (cover more horizontal area).
Additionally it was found during an early experiment that short plants were generally displeasing.
Like the Foliage metric, the Length metric is asymptotic towards 1 as the plant length increases towards $\infty$.
This is shown in Equation~\ref{eq:length}.
The length of the plant is found using $longest$, which finds the longest path in the branches of the plant from root to leaf and returns the number of \glspl{branch segment} in it.
As with the Foliage metric, the $s$ constant controls how fast it should increase towards 1.

\begin{equation}
\label{eq:length}
    length(x) = \frac{longest(x) * s}{1 + length(x) * s}, \text{where } s = 0.5
\end{equation}

\textit{Curvature} is a metric that rewards plants with more curved branches.
It was developed from the results of the first experiment where it was found that plants that looked ``static'' or ``straight'' were not as pleasing as plants that looked more ``dynamic'' or ``curvy''.
As Equation~\ref{eq:curvature} demonstrates, the plant is rewarded more if the \glspl{branch segment} are oriented with a small angle different from their parent.
If the angle is too sharp, the plant is rewarded less, as the plant may look like ``doodles'' with such angles.
The $minangles$ function returns a list of the smallest angle from an \gls{internode segment} to its parent segments.
Thus, if an \gls{internode segment} only has one child (i.e.\ it does not branch), the smallest angle will be the angle between it and that one child.
Otherwise, if an \gls{internode segment} has multiple children (i.e.\ it is a \gls{branch base}), all of the angles between it and the children are calculated and the smallest will be used.
This is based on the assumption that the \gls{child segment} with the smallest angle is the \gls{straight segment} following a \gls{branch base}.
% This assumption only holds for apex trees? What if it branches into two equally angled branches?
$avg$ calculates the average of all of the angles returned by $minangles$.
Like in Equation~\ref{eq:complexity}, $icos$ is used to create a smooth interpolation between the limits $min$, $opt$ and $max$.
A sweet spot of $opt = 0.24711092$, which is rewarded by 1, was found to provide a good curvature in the plant.
A limit of $max = \frac{\pi}{4}$ (45°) was intuitively chosen as a point where the curvature is no longer rewarding.

\begin{equation}
\label{eq:curvature}
\begin{aligned}
    curvature(x) =
    \begin{cases}
        icos(0, 1, \frac{a - min}{opt - min}), & a >= min \text{ and } a < opt \\
        icos(1, 0, \frac{a - opt}{max - opt}), & a >= opt \text{ and } a < max \\
        min, & \text{otherwise}
    \end{cases}, \\
    \text{where } a = avg(minangles(x)), \\
    min = 0, \\
    opt = 0.24711092, \\
    max = \frac{\pi}{4} \\
\end{aligned}
\end{equation}
